package thread.ext.jmm;


/**
 * 并发领域的关键问题：线程的通信和同步
 *      通信：以何种机制来交换信息，共享内存（读写同一个位置）和消息传递（等待唤醒等）
 *      同步：控制不同线程之间操作发生相对顺序的机制
 *          在共享内存里面，同步是显示的，程序员必须显示指定某个方法或某段代码需要在线程之间互斥执行（java的并发采用的是共享内存模型）
 *          在消息传递里面，由于消息的发送必须在消息的接受之前，因此同步是隐式的
 *      高速缓存带来的缓存一致性问题
 *      java内存模型和现代计算机模型是差不多的
 *          在当前工作内存存放读写变量的副本
 *          线程a         工作内存         |
 *                                      |
 *                                      |
 *          线程b         工作内存        | -------save和load操作------主内存
 *                                      |
 *                                      |
 *          线程c         工作内存        |
 *      执行方法是以栈帧的形式，被打包到栈的。
 *      堆：堆中对象可以被多线程共享，如果一个线程获得一个对象的应用，它便可以访问这个对象的成员变量。如果两个线程同时调用了同一个对象的同一个方法，那么这两个线程便可同时访问这个对象的成员变量，但是对于局部变量，每个线程都会拷贝副本
 *      java内存模型带来的问题：可见性和竞争
 *      java内存模型中的重排序：
 *          源代码->编译器优化[1]->指令级并行重排序[2,多条指令并发执行]->内存系统重排序[3，读写缓存]->最终执行指令序列
 *          重排序与数据依赖：
 *              数据依赖（一般不会重排序）：写后读 a = 1,b = a，写后写 a = 1,a = 2，读后写 a = b,b = 1
 *              控制依赖：if(b == 1)a = 2;  a是否等于2 依赖b的值，这种情况也是会重排序的[是有可能被重排序的，猜测技术，temp = 2 if(b == 1)a = temp]
 *              as-if-serial概念（编译器遵守的）：不管怎么重排序，保证在单线程下运行正确并且一致，在单线程下，就不用考虑指令重排序了，但是在多线程下，就不一样了
 *          解决多线程下的重排序问题：内存屏障[保证操作的执行顺序，保证数据的内存可见性]，也就是1.禁止重排序，2.强制刷出缓存
 *                               临界区：加锁[临界区内部可以重排序]
 *          内存屏障：
 *                  1.Load1;LoadLoad;Load2 确保Load1数据的装载，之前于Load2及所有后续装载指令的装载
 *                  2.Store1;StoreStore;Store2 确保Store1数据堆其他处理器可见(刷新到内存)，之前于Store2及所有后续存储指令的存储
 *                  3.Load1;LoadStore;Store2   确保Load1数据装载，之前于Store2及所有后续的存储指令刷新到内存  保证读取先完成之后才进行写操作
 *                  4.Store1;StoreLoad;Load2   确保Store1数据对其他处理器变得可见（指刷新到内存），之前于Load2及所有后续装载指令的装载。StoreLoad 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令
 *          happens-before：
 *              用happens-before的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系 。
 *              两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前
 *              加深理解：
 *                  如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。(对程序员来说)
 *                  两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序是允许的(对编译器和处理器 来说)
 *              happens-before规则：无需任何同步手段就可以保证的
 *                  1）程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
 *                  2）监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
 *                  3）volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
 *                  4）传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。
 *                  5）start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。
 *                  6）join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。
 *                  7）线程中断规则:对线程interrupt方法的调用happens-before于被中断线程的代码检测到中断事件的发生。
 *          volatile的内存语义：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。
 *                  可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入
 *                  原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。
 *          volatile内存语义的实现：
 *                  JMM对volatile的内存屏障插入策略
 *                      在每个volatile写操作的前面插入一个StoreStore屏障。在每个volatile写操作的后面插入一个StoreLoad屏障。
 *                      在每个volatile读操作的后面插入一个LoadLoad屏障。在每个volatile读操作的后面插入一个LoadStore屏障。
 *          volatile的实现原理：
 *                  有volatile变量修饰的共享变量进行写操作的时候会使用CPU提供的Lock前缀指令
 *                      将当前处理器缓存行的数据写回到系统内存
 *                      这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。
 *          synchronized实现原理：
 *                  使用monitorenter和monitorexit指令实现的
 *                      monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处
 *                      每个monitorenter必须有对应的monitorexit与之配对
 *                      任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态
 *          锁的内存语义：
 *                  当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。
 *                  当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。
 *          final的内存语义：
 *                  在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。
 *                  初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。
 *                  final域为引用类型：
 *                      增加了如下规则：在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。
 *                  final语义在处理器中的实现：
 *                      会要求编译器在final域的写之后，构造函数return之前插入一个StoreStore障屏。
 *                      读final域的重排序规则要求编译器在读final域的操作前面插入一个LoadLoad屏障
 */
public class AllTest {
    public static void main(String[] args) {

    }
}
