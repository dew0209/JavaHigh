网络模型

```xml
各层的关系
	每一个抽象层的建立在低一层提供的服务上，并且为高一层提供服务。
程序员重点关注
	应用层
	表示层
	会话层
	传输层
非程序员重点关注
	网络层
	链路层
	物理层
```

![image-20210922163858065](C:/Users/吕露的小可爱/AppData/Roaming/Typora/typora-user-images/image-20210922163858065.png)

TCP/IP是Internet最基本的协议。把所有TCP/IP系列协议归类到四个抽象层中

![image-20210922164027419](C:/Users/吕露的小可爱/AppData/Roaming/Typora/typora-user-images/image-20210922164027419.png)

TCP三次握手

```xml
三次握手
	建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立
为什么需要3次握手？
	TCP是面对连接的，所以需要双方都确认来连接的建立
第一次握手
	客户端请求建立连接
第二次握手
	服务端应答客户端，并请求建立连接
第三次握手
	客户端针对服务端请求确认应答

TCP的3次握手的漏洞
	SYN洪泛攻击
		定义：通过网络服务所在的端口发送大量伪造原地址的攻击报文，发送到服务端，造成服务端上的半开连接队列被占满，从而阻止其他用户进行访问。
	原理：
		攻击者客户端利用伪造的IP地址向服务端发送请求（第一次握手），而服务端的响应（第二次握手）的报文将永远发送不到真实的客户端，服务端在等待客户端的第三次握手（永远都不会有的），服务端在等待这种半开的连接过程中消耗了资源，如果有成千上万的这种连接，主机资源将被耗尽，从而达到攻击的目的。
	解决方案：
		无效连接监控释放
		延缓TCB分配方法
		防火墙
```

TCP的4次挥手协议

```xml
定义：
	断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开
为什么需要四次挥手：
	TCP是全双工（即客户端和服务器端可以相互发送和接受请求），所以需要双方都确认关闭连接
过程：
	第一次挥手：客户端发送关闭请求
	第二次挥手：服务端响应客户端关闭请求
	服务端发送关闭请求
	客户端发送关闭确认请求
```

TCP中的滑动窗口协议--可靠和高效的结合

```xml
滑动窗口
	发送方和接受方都会维护一个数据帧的序列，这个序列被称作窗口
	发送方的窗口大小由接收方确认
目的：
	确保数据不丢失
		如果发送的数据丢失了可以重新发
	控制发送速度
		控制发送速度，以免接收方的缓存不够大导致溢出，同时控制流量也可避免网络拥塞
```

HTTP协议的报文组成

```xml
请求报文
	请求行
	请求头
	请求体
响应报文
	状态行
	首部行
	返回体
```

| 状态码 |      类别      |            原因            |
| :----: | :------------: | :------------------------: |
|  1xx   |    提示信息    |     接受的请求正在处理     |
|  2xx   |      成功      |      请求正常处理完毕      |
|  3xx   |     重定向     | 需要进行附加操作已完成请求 |
|  4xx   |   客户端错误   |     服务器无法处理请求     |
|  5xx   | 服务器端的错误 |     服务器处理请求出错     |

UDP协议

```xml
UDP
	面向无连接的通讯协议
	通讯时不需要接受方确认，属于不可靠的传输
	因为不需要建立连接，所以传输速度快，但是容易丢失数据
UDP是将数据打包成数据包向对方发送，只关心是否发送成功，而不关心是否接受成功，传输速度快， 但是可靠性低。
	DatagramSocket：表示用来发送和接受数据报包的套接字
	DatagramPacket：数据包对象
```

报文组成

```xml
源端口：源端目标，在需要对方回信时选用，不需要时可用全0
目的端口：目的端口号，这在终点交付报文时必须要使用到
长度：UDP用户数据包的长度，其最小值是8（仅有首部）
校验和：检测UDP用户数据报在传输中是否有错，有错就丢弃
```

网络模型总结

```xml
TCP
	三次握手--洪泛攻击
	四次握手
	TCP缓冲区---阻塞和滑动窗口
	HTTP
UDP

TCP通讯原理：
	socket套接字
		tcp用主机的ip地址加上主机上的都口号作为tcp连接的端点，这种端口就叫做套接字（socket）
	TCP缓冲区
		每次tcp的socket的内核中都有一个发送缓冲区和一个接受缓冲区
	阻塞模式
		接受端缓冲区为空，接受端调用read方法的线程阻塞
		发送端缓冲区满了或者不够大，发送端调用write方法的线程阻塞
	TCP的可靠性与高效率
		有了缓冲区之后我们怎么传输才能确保高效与可靠
```

![image-20210922171612616](C:/Users/吕露的小可爱/AppData/Roaming/Typora/typora-user-images/image-20210922171612616.png)

rpc

```xml
远程过程调用
	调用远程计算机上的服务，就像调用本地服务一样

请求调用服务
		|
		|变成
		|
请求去注册中心找服务，找到调用，服务注册到注册中心

RPC的Java版本---RMI
	RMI概述
		RMI可以认为是RPC的Java版本，允许运行在一个Java虚拟机的对象调用运行在另一个Java虚拟机上对象的方法。
	实现原理
		RMI使用的是JRMP协议，JRMP是专门为Java定制的通信协议，所以是纯Java的分布式解决方案。
	实现一个RMI程序
		1.创建一个远程接口，并继承java.rmi.Remote接口
		2.实现远程接口，并继承UnicastRemoteObject
		3.创建服务器程序，同时使用createRegistry方法注册远程接口对象
		4.创建客户端程序，通过Naming类的lookup方法来远程调用接口中的方法
```

