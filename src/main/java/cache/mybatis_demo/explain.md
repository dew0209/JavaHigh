# MyBatis缓存模块

前提

```xml
MyBatis缓存的实现是基于Map实现的，从缓存里面读写数据是缓存模块的核心基础功能
除核心功能之外，有很多额外的附加功能，如：防止缓存击穿，添加缓存清空策略（fifo，lru），序列化功能，日志能力，定时清空能力等
附加功能可以任意的组合附加到核心基础功能之上
```

怎么样优雅的为核心功能添加附加能力？

```xml
使用继承
	继承的方式是静态的，用户不能控制增加行为的方式和时机。另外，新功能的存在多种组合，使用继承可能导致大量子类存在。
装饰器模式
	装饰器模式是一种用于代替继承的技术，无需通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。
```

装饰器优点

```xml
相对于继承，装饰器模式灵活性更强，扩展性更强
	灵活性：装饰器模式将功能切分成一个个独立的装饰器，在运行期可以根据需要动态的添加功能，甚至对添加的新功能进行自由的组合
	扩展性：当有新功能要添加的时候，只需要添加新的装饰器实现类，然后通过组合方式添加这个新装饰器类，无需修改已有代码，符合开闭原则
例子：IO流
```

MyBatis cache接口

```xml
Cache：Cache接口是缓存模块的核心接口，定义了缓存的基本操作
PerpetualCache：使用HashMap来实现cache的相关操作
BlockingCache：阻塞版本的缓存装饰器，保证只有一个线程到数据库去查找指定的key对应的数据
```

CacheKey解读

```xml
MyBatis中涉及到动态SQL的原因，缓存项的key不能仅仅通过一个String来表示，所以通过CacheKey来封装缓存的key值，CacheKey可以封装多个缓存项的因素，判断两个CacgeKey是否相同关键是比较两个对象的hash值是否一致。
构成CacheKey的对象：
	1.mappedStatment的id
	2.指定查询结果集的范围（分页信息）
	3.查询锁使用的SQL语句
	4.用户传递给SQL语句的实际参数值
重点方法解读：
	update(Object obj)
	equals(Object obj)
```

